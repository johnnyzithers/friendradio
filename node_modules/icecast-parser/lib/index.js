'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _StreamReader = require('./StreamReader');

var _StreamReader2 = _interopRequireDefault(_StreamReader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Default options
 * @description :: Default configuration object for RadioParser
 * @type {Object}
 * @private
 */
var DEFAULT_OPTIONS = {
  keepListen: false,
  autoUpdate: true,
  errorInterval: 10 * 60,
  emptyInterval: 5 * 60,
  metadataInterval: 5
};

var RadioParser = function (_EventEmitter) {
  _inherits(RadioParser, _EventEmitter);

  /**
   * RadioParser class
   * @param {Object|String} options Configuration object or string with radio station URL
   * @constructor
   */

  function RadioParser(options) {
    _classCallCheck(this, RadioParser);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RadioParser).call(this));

    if (typeof options === 'string') {
      _this.setConfig({ url: options });
    } else {
      _this.setConfig(options);
    }

    _this.queueRequest();
    return _this;
  }

  /**
   * When request to radio station is successful this function is called
   * @param response
   * @returns {RadioParser}
   * @private
   */

  _createClass(RadioParser, [{
    key: '_onRequestResponse',
    value: function _onRequestResponse(response) {
      var _this2 = this;

      var icyMetaInt = response.headers['icy-metaint'];

      if (icyMetaInt) {
        var reader = new _StreamReader2.default(icyMetaInt);

        reader.on('metadata', function (metadata) {
          _this2._destroyResponse(response);
          _this2._queueNextRequest(_this2.getConfig('metadataInterval'));
          _this2.emit('metadata', metadata);
        });

        response.pipe(reader);
        this.emit('stream', reader);
      } else {
        this._destroyResponse(response);
        this._queueNextRequest(this.getConfig('emptyInterval'));
        this.emit('empty');
      }

      return this;
    }

    /**
     * Called when some error in request is appears
     * @param error
     * @returns {RadioParser}
     * @private
     */

  }, {
    key: '_onRequestError',
    value: function _onRequestError(error) {
      this._queueNextRequest(this.getConfig('errorInterval'));
      this.emit('error', error);
      return this;
    }

    /**
     * Make request to radio station and get stream
     * @private
     */

  }, {
    key: '_makeRequest',
    value: function _makeRequest() {
      var request = _http2.default.request(this.getConfig('url'));

      request.setHeader('Icy-MetaData', '1');
      request.setHeader('User-Agent', 'Mozilla');
      request.once('response', this._onRequestResponse.bind(this));
      request.once('error', this._onRequestError.bind(this));
      request.end();

      return this;
    }

    /**
     * Check if response can be destroyed
     * @param {IncomingMessage} response
     * @returns {RadioParser}
     * @private
     */

  }, {
    key: '_destroyResponse',
    value: function _destroyResponse(response) {
      if (!this.getConfig('keepListen')) response.destroy();
      return this;
    }

    /**
     * Queue next request with checking if next request is needed
     * @param {Number} timeout Timeout in seconds for next request
     * @returns {RadioParser}
     * @private
     */

  }, {
    key: '_queueNextRequest',
    value: function _queueNextRequest(timeout) {
      if (this.getConfig('autoUpdate') && !this.getConfig('keepListen')) this.queueRequest(timeout);
      return this;
    }

    /**
     * Queue request to radio station after some time
     * @param {Number} [timeout] Timeout in seconds
     * @returns {RadioParser}
     */

  }, {
    key: 'queueRequest',
    value: function queueRequest() {
      var timeout = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];

      setTimeout(this._makeRequest.bind(this), timeout * 1000);
      return this;
    }

    /**
     * Get configuration object or configuration value by key
     * @param {String} [key] Key name
     * @returns {*} Returns appropriate value by key or configuration object
     */

  }, {
    key: 'getConfig',
    value: function getConfig(key) {
      return key ? this._config[key] : this._config;
    }

    /**
     * Set configuration object or set configuration key with new value
     * @param {Object} config New configuration object
     * @returns {RadioParser}
     */

  }, {
    key: 'setConfig',
    value: function setConfig(config) {
      if (!this._config) {
        var defaultConfig = Object.assign({}, DEFAULT_OPTIONS);
        this._config = Object.assign(defaultConfig, config);
      } else {
        this._config = Object.assign(this._config, config);
      }

      return this;
    }
  }]);

  return RadioParser;
}(_events2.default);

exports.default = RadioParser;
module.exports = exports['default'];