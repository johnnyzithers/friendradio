'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _stream = require('stream');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * "Init" state
 * @description :: State which indicates that StreamReader is initializing
 * @type {Number}
 * @private
 */
var INIT_STATE = 1;

/**
 * "Buffering" state
 * @description :: State which indicates that StreamReader is grabbing data to buffer
 * @type {Number}
 * @private
 */
var BUFFERING_STATE = 2;

/**
 * "Pass through" state
 * @description :: State which indicates that StreamReader is just sends data without caching
 * @type {Number}
 * @private
 */
var PASSTHROUGH_STATE = 3;

/**
 * Block size of metadata
 * @description :: How many bytes need to multiply to number from response.headers['icy-metaint']
 * @type {Number}
 * @private
 */
var METADATA_BLOCK_SIZE = 16;

/**
 * Parse metadata to object
 * @param {Buffer|String} metadata Buffer or string with metadata information
 * @returns {Object}
 * @private
 */
var _parseMetadata = function _parseMetadata(metadata) {
  var data = Buffer.isBuffer(metadata) ? metadata.toString('utf8') : metadata || '';
  var result = {};

  data.replace(/\0*$/, '').split(';').forEach(function (item) {
    item = item.split(/\=['"]/);
    result[item[0]] = String(item[1]).replace(/['"]$/, '');
  });

  return result;
};

/**
 * Helper method that returns trampolined function
 * @param {Function} fn Function that need to trampoline
 * @returns {Function} Returns trampolined function
 * @private
 */
var _trampoline = function _trampoline(fn) {
  return function () {
    var result = fn.apply(this, arguments);
    while (typeof result === 'function') {
      result = result();
    }return result;
  };
};

/**
 * Process one chunk of data
 * @param {StreamReader} stream StreamReader instance
 * @param {Buffer} chunk Chunk of data
 * @param {Function} done Triggers when processing is done
 * @returns {Function}
 * @private
 */
var _processData = function _processData(stream, chunk, done) {
  stream._bytesLeft -= chunk.length;

  if (stream._currentState === BUFFERING_STATE) {
    stream._buffers.push(chunk);
    stream._buffersLength += chunk.length;
  } else if (stream._currentState === PASSTHROUGH_STATE) {
    stream.push(chunk);
  }

  if (stream._bytesLeft === 0) {
    var cb = stream._callback;

    if (cb && stream._currentState === BUFFERING_STATE && stream._buffers.length > 1) {
      chunk = Buffer.concat(stream._buffers, stream._buffersLength);
    } else if (stream._currentState !== BUFFERING_STATE) {
      chunk = null;
    }

    stream._currentState = INIT_STATE;
    stream._callback = null;
    stream._buffers.splice(0);
    stream._buffersLength = 0;

    cb.call(stream, chunk);
  }

  return done;
};

/**
 * Function to which sends all data from `_transform` function
 * @param {StreamReader} stream StreamReader instance
 * @param {Buffer} chunk Chunk of data
 * @param {Function} done Function that triggers when processing is done
 * @type {Function}
 * @private
 */
var _onData = _trampoline(function (stream, chunk, done) {
  if (chunk.length <= stream._bytesLeft) {
    return function () {
      return _processData(stream, chunk, done);
    };
  } else {
    return function () {
      var buffer = chunk.slice(0, stream._bytesLeft);

      return _processData(stream, buffer, function (error) {
        if (error) return done(error);
        if (chunk.length > buffer.length) {
          return function () {
            return _onData(stream, chunk.slice(buffer.length), done);
          };
        }
      });
    };
  }
});

var StreamReader = function (_Transform) {
  _inherits(StreamReader, _Transform);

  /**
   * Creates new transform stream which emits `metadata` event when it will be read
   * @param {Number} icyMetaInt Number of bytes from response headers which shows how many bytes need to skip
   * @constructor
   */

  function StreamReader(icyMetaInt) {
    _classCallCheck(this, StreamReader);

    // How many bytes left to read

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(StreamReader).call(this));

    _this._bytesLeft = 0;

    // Current state of reader, what the reader should do with received bytes
    _this._currentState = INIT_STATE;

    // Callback for the next chunk
    _this._callback = null;

    // Array of collected Buffers
    _this._buffers = [];

    // How many bytes already read
    _this._buffersLength = 0;

    // icy-metaint number from radio response
    _this._icyMetaInt = +icyMetaInt;

    _this._passthrough(_this._icyMetaInt, _this._onMetaSectionStart);
    return _this;
  }

  /**
   * Collect bytes in buffer and trigger callback with collected chunk
   * @param {Number} length Length of bytes that need to read
   * @param {Function} cb Callback function with collected data in arguments
   * @returns {StreamReader}
   * @private
   */

  _createClass(StreamReader, [{
    key: '_bytes',
    value: function _bytes(length, cb) {
      this._bytesLeft = length;
      this._currentState = BUFFERING_STATE;
      this._callback = cb;
      return this;
    }

    /**
     * Pass through Transform stream and trigger callback after all data is sent
     * @param {Number} length Length of bytes to pass through
     * @param {Function} cb Callback function when all data will be sent
     * @returns {StreamReader}
     * @private
     */

  }, {
    key: '_passthrough',
    value: function _passthrough(length, cb) {
      this._bytesLeft = length;
      this._currentState = PASSTHROUGH_STATE;
      this._callback = cb;
      return this;
    }

    /**
     * Transform stream processor
     * @param {Buffer} chunk Chunk of data
     * @param {String} encoding Current encoding of chunk
     * @param {Function} done Callback function when processing is done
     * @returns {Function}
     * @private
     */

  }, {
    key: '_transform',
    value: function _transform(chunk, encoding, done) {
      _onData(this, chunk, done);
    }

    /**
     * Triggers when metadata section is starting
     * @private
     */

  }, {
    key: '_onMetaSectionStart',
    value: function _onMetaSectionStart() {
      this._bytes(1, this._onMetaSectionLengthByte);
    }

    /**
     * Triggers when we read 1 byte with metadata section length
     * @param chunk Chunk where located length byte
     * @private
     */

  }, {
    key: '_onMetaSectionLengthByte',
    value: function _onMetaSectionLengthByte(chunk) {
      var length = chunk[0] * METADATA_BLOCK_SIZE;

      if (length > 0) {
        this._bytes(length, this._onMetaData);
      } else {
        this._passthrough(this._icyMetaInt, this._onMetaSectionStart);
      }
    }

    /**
     * Triggers when metadata is collected
     * @param chunk Metadata buffer
     * @private
     */

  }, {
    key: '_onMetaData',
    value: function _onMetaData(chunk) {
      this.emit('metadata', _parseMetadata(chunk));
      this._passthrough(this._icyMetaInt, this._onMetaSectionStart);
    }
  }]);

  return StreamReader;
}(_stream.Transform);

exports.default = StreamReader;
module.exports = exports['default'];